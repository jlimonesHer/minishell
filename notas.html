<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Notas de minishell</title>
</head>
<body>
	<table>
		<th class="nombre">Funciones autorizadas</th>
		<th class="descrip">Descripcion</th>
		<th class="prototipo">Prototipo</th>
		<th class="nombre">libreria</th>
		<tr>
			<td class="nombre">readline</td>
			<td class="descrip">La función readline() en C se utiliza para leer una línea de entrada de un usuario desde la 
				consola. Esta función es muy útil para leer líneas de entrada de usuario de longitud desconocida. Hay que incluir en el make
				-ireadline o no linkea el main</td>
			<td class="prototipo">char *readline(const char *prompt);</td>
			<td class="libreria">readline.h</td>
		</tr>
		<tr>
			<td class="nombre">rl_clear_history</td>
			<td class="descrip">es una función de la biblioteca readline en C que se
				 utiliza para borrar todo el historial de comandos almacenado en la memoria por la biblioteca readline.</td>
			<td class="prototipo">rl_clear_history();</td>
			<td class="libreria">readline/history.h</td>
		</tr>
		<tr>
			<td class="nombre">rl_on_new_line</td>
			<td class="descrip"> es una función de la biblioteca readline en C que se utiliza para indicarle a la biblioteca readline 
				que se ha escrito una nueva línea en la terminal. Esta función es útil para controlar 
				el comportamiento de la biblioteca readline después de que se escribe una nueva línea en la terminal.</td>
			<td class="prototipo">rl_on_new_line();</td>
			<td class="libreria">readline/history.h</td>
		</tr>
		<tr>
			<td class="nombre">rl_replace_line</td>
			<td class="descrip">??????????</td>
			<td class="prototipo">?????????</td>
			<td class="libreria">??????????</td>
		</tr>
		<tr>
			<td class="nombre">rl_redisplay</td>
			<td class="descrip">Esta función no toma ningún argumento y no devuelve ningún valor. Su único propósito
				 es actualizar la pantalla y volver a mostrar la línea de entrada actual. Para utilizar esta función, 
				se debe incluir la biblioteca "readline/readline.h" en el archivo fuente de C.</td>
			<td class="prototipo">void rl_redisplay(void);</td>
			<td class="libreria">readline/readline.h</td>
		</tr>
		<tr>
			<td class="nombre">add_history</td>
			<td class="descrip">La función "add_history" agrega una nueva entrada de comando a un historial de entradas previas. 
				Esto significa que cuando el usuario utiliza las teclas de flecha arriba/abajo para navegar por el historial de comandos, las entradas de comando anteriores se mostrarán, 
				lo que hace que sea más fácil para el usuario repetir comandos antiguos.</td>
			<td class="prototipo">void add_history(const char *line);</td>
			<td class="libreria">readline/history.h</td>
		</tr>
		<tr>
			<td class="nombre">access</td>
			<td class="descrip">La función "access" en C se utiliza para comprobar si el proceso tiene acceso a un archivo específico. 
				Esta función comprueba si el usuario actual tiene los permisos necesarios para realizar una operación
				 en un archivo determinado, como leer o escribir en el archivo</td>
			<td class="prototipo">int access(const char *pathname, int mode);</td>
			<td class="libreria">unistd.h</td>
		</tr>
		<tr>
			<td class="nombre">wait</td>
			<td class="descrip">La función wait() espera a que el proceso hijo termine su ejecución y luego devuelve el identificador del proceso hijo
				status es un puntero a una variable que se utiliza para almacenar el estado de salida del proceso hijo.</td>
			<td class="prototipo">pid_t wait(int *status);</td>
			<td class="libreria">unistd.h</td>
		</tr>
		<tr>
			<td class="nombre">waitpid</td>
			<td class="descrip">función waitpid() para esperar a un proceso hijo específico en lugar de esperar al primero que termine.
				pid es el identificador del proceso hijo que se desea esperar. Si se especifica -1, waitpid() esperará a cualquier proceso hijo.
				status es un puntero a una variable que se utiliza para almacenar el estado de salida del proceso hijo.
				options es un entero que especifica varias opciones que se pueden utilizar con waitpid(), 
				como WNOHANG, que indica que waitpid() debe regresar inmediatamente en lugar de esperar a que el proceso hijo termine.
			</td>
			<td class="prototipo">pid_t waitpid(pid_t pid, int *status, int options);</td>
			<td class="libreria">unistd.h</td>
		</tr>
		<tr>
			<td class="nombre">wait3</td>
			<td class="descrip">versiones mejoradas de la función wait(), y proporcionan información adicional sobre el proceso hijo que ha finalizado.
				status es un puntero a una variable que se utiliza para almacenar el estado de salida del proceso hijo.
				options es un entero que especifica varias opciones que se pueden utilizar con wait3(), como WNOHANG, que indica que wait3() debe regresar inmediatamente en lugar de esperar a que el proceso hijo termine.
				rusage es un puntero a una estructura rusage que se utiliza para almacenar información sobre los recursos utilizados por el proceso hijo.
			</td>
			<td class="prototipo">pid_t wait3(int *status, int options, struct rusage *rusage);</td>
			<td class="libreria">sys/wait.h</td>
		</tr>
		<tr>
			<td class="nombre">wait4</td>
			<td class="descrip">acepta un argumento adicional que se utiliza para especificar una señal que debería interrumpir la espera de procesos secundarios</td>
			<td class="prototipo">pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);</td>
			<td class="libreria">sys/wait.h</td>
		</tr>
		<tr>
			<td class="nombre">signal</td>
			<td class="descrip">En C, la función signal() se utiliza para manipular señales en el sistema operativo UNIX. Las señales son una forma de comunicación entre procesos y entre procesos y el kernel, y se utilizan para notificar a un proceso de eventos importantes, como errores de hardware, eventos de temporización o solicitudes de interrupción.
				signum es el número de la señal a manejar. Las señales tienen números asociados que se utilizan para identificarlas, como SIGINT (2) para la señal de interrupción del teclado.
				handler es un puntero a una función que se llama cuando se recibe la señal especificada.
			</td>
			<td class="prototipo">void (*signal(int signum, void (*handler)(int)))(int);</td>
			<td class="libreria">signal.h</td>
		</tr>
		<tr>
			<td class="nombre">sigaction</td>
			<td class="descrip">se utiliza para cambiar el comportamiento de una señal en el sistema operativo UNIX. La función sigaction() es una alternativa más flexible a la función signal(), y se utiliza para establecer un manejador de señal y definir las opciones de la señal para un proceso específico.
				signum es el número de la señal a manejar. Las señales tienen números asociados que se utilizan para identificarlas, como SIGINT (2) para la señal de interrupción del teclado.
				act es un puntero a una estructura sigaction que especifica el nuevo manejador de señal y las opciones de la señal.
				oldact es un puntero opcional a una estructura sigaction que se utiliza para almacenar la información del manejador de señal anterior. mirar struck!!!
			</td>
			<td class="prototipo">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</td>
			<td class="libreria">signal.h</td>
		</tr>
		<tr>
			<td class="nombre">kill</td>
			<td class="descrip"> se utiliza para enviar una señal a un proceso específico en el sistema operativo UNIX. La señal especificada puede ser cualquier señal definida en el sistema operativo, como SIGTERM para solicitar que un proceso se cierre o SIGKILL para forzar su cierre inmediato.
				pid es el identificador del proceso al que se enviará la señal. Si pid es mayor que 0, se envía la señal al proceso con ese ID. Si pid es igual a 0, la señal se envía a todos los procesos en el grupo de procesos actual. Si pid es igual a -1, la señal se envía a todos los procesos a los que el proceso actual tiene permiso para enviar señales.
				sig es el número de la señal a enviar, como SIGTERM o SIGKILL.
			</td>
			<td class="prototipo">int kill(pid_t pid, int sig);</td>
			<td class="libreria">sin libreria</td>
		</tr>
		<tr>
			<td class="nombre">getcwd</td>
			<td class="descrip">en C (abreviatura de "get current working directory") se utiliza para obtener el directorio actual de trabajo del proceso en el que se está ejecutando el programa.
				buf es un puntero a un búfer que se utiliza para almacenar la ruta del directorio actual.
				size es el tamaño máximo del búfer en bytes.
			</td>
			<td class="prototipo">char *getcwd(char *buf, size_t size);</td>
			<td class="libreria">unistd.h/limits.h</td>
		</tr>
		<tr>
			<td class="nombre">chdir</td>
			<td class="descrip">se utiliza para cambiar el directorio de trabajo actual del proceso en el que se está ejecutando el programa.</td>
			<td class="prototipo">int chdir(const char *path);</td>
			<td class="libreria">unistd.h</td>
		</tr>
		<tr>
			<td class="nombre">stat</td>
			<td class="descrip">se utiliza para obtener información sobre un archivo en particular. La información que se puede obtener mediante esta función incluye detalles sobre el tamaño del archivo, su fecha de creación, su fecha de modificación y permisos de acceso, entre otros.
				path es una cadena de caracteres que representa la ruta del archivo que se desea obtener información.
				buf es un puntero a una estructura stat en la que se almacenará la información obtenida por la función. mirar struck!!!
			</td>
			<td class="prototipo">int stat(const char *path, struct stat *buf);</td>
			<td class="libreria"></td>
		</tr>
		<tr>
			<td class="nombre"></td>
			<td class="descrip"></td>
			<td class="prototipo"></td>
			<td class="libreria"></td>
		</tr>
		<tr>
			<td class="nombre"></td>
			<td class="descrip"></td>
			<td class="prototipo"></td>
			<td class="libreria"></td>
		</tr>
		<tr>
			<td class="nombre"></td>
			<td class="descrip"></td>
			<td class="prototipo"></td>
			<td class="libreria"></td>
		</tr>
		<tr>
			<td class="nombre"></td>
			<td class="descrip"></td>
			<td class="prototipo"></td>
			<td class="libreria"></td>
		</tr>
		<tr>
            <td class="nombre">perror</td>
            <td class="descrip">se utiliza para imprimir un mensaje de error en la salida estándar que describe el último error que ocurrió en el programa.</td>
            <td class="prototipo">void perror(const char *s);</td>
            <td class="libreria">errno.h</td>
        </tr>
        <tr>
            <td class="nombre">isatty</td>
            <td class="descrip">Se utiliza para determinar si un descriptor de archivo (como STDIN_FILENO, STDOUT_FILENO o STDERR_FILENO) se refiere a un terminal interactivo.</td>
            <td class="prototipo">int isatty(int fd);</td>
            <td class="libreria">unistd.h</td>
        </tr>
        <tr>
            <td class="nombre">ttyname</td>
            <td class="descrip">Se utiliza para determinar el nombre del dispositivo de entrada/salida de terminal asociado al descriptor de archivo dado.</td>
            <td class="prototipo">char *ttyname(int fd);</td>
            <td class="libreria">unistd.h</td>
        </tr>
        <tr>
            <td class="nombre">ttyslot</td>
            <td class="descrip">Se utiliza para determinar el número de entrada/salida de terminal asociado al proceso actual.</td>
            <td class="prototipo">int ttyslot(void);</td>
            <td class="libreria">unistd.h</td>
        </tr>
        <tr>
            <td class="nombre">ioctl</td>
            <td class="descrip">Se utiliza para controlar dispositivos de entrada/salida a través de comandos específicos enviados al controlador del dispositivo.</td>
            <td class="prototipo">int ioctl(int fd, unsigned long request, ...);</td>
            <td class="libreria">unistd.h</td>
        </tr>
        <tr>
            <td class="nombre">getenv</td>
            <td class="descrip">Se utiliza para obtener el valor de una variable de entorno en el sistema operativo.</td>
            <td class="prototipo">char *getenv(const char *nombre);</td>
            <td class="libreria">stdlib.h</td>
        </tr>
        <tr>
            <td class="nombre">tcsetattr</td>
            <td class="descrip">Se utiliza para establecer los atributos del terminal en un descriptor de archivo dado. Los atributos del terminal incluyen cosas como la velocidad de transmisión, el tamaño del carácter y los modos de control de flujo, entre otros.</td>
            <td class="prototipo">int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);</td>
            <td class="libreria">termios.h</td>
        </tr>
        <tr>
            <td class="nombre">tcgetattr</td>
            <td class="descrip">Se utiliza para obtener los atributos del terminal en un descriptor de archivo dado. Los atributos del terminal incluyen cosas como la velocidad de transmisión, el tamaño del carácter y los modos de control de flujo, entre otros.</td>
            <td class="prototipo">int tcgetattr(int fd, struct termios *termios_p);</td>
            <td class="libreria">termios.h</td>
        </tr>
        <tr>
            <td class="nombre">tgetent</td>
            <td class="descrip">Su función es leer y analizar las entradas del archivo de base de datos de terminal, y cargar los valores correspondientes en la estructura de datos de terminal term, que se utiliza para controlar la apariencia y el comportamiento de la pantalla.</td>
            <td class="prototipo">int tgetent(char *bp, const char *name);</td>
            <td class="libreria">curses.h</td>
        </tr>
	</table>
</body>
</html>